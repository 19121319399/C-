2023.04.04
1、每一个数据类型都有取值范围，为什么会这样取？
无符号类型
以一个4位二进制举例
全部为数据位。4位二进制编码：0000-1111共8种，所以能表示0-7(23-1)。
总结：对于有符号类型，如果是n位，则表示范围为 0 - 2n-1。
有符号类型
以一个4位二进制举例
如果以原码表示：对于有符号类型，最高位是符号位，剩下的4-1=3位是数据位。所以数据为最多有8种编码情况。000-111所以取值范围为：-7(23-1)~-0和+0到+7，共15个数字。

计算机实际以补码形式存储整数。
对于正数，补码与原码相同，范围依旧是+0到+7(23-1)。
对于负数，补码是对其原码逐位取反，但符号位除外；然后整个数加1。

-7的二进制原码：1111，所以补码为：1001。
-1的二进制原码：1001，所以补码为：1111。
-0的二进制原码:1000，所以补码为：0000。与+0相同。（所以用它来表示个其他数吧）
没有任何数的补码是：1000这个编码。所以多出来了。所以，规定1000这个补码编码为-8。

综上：4位二进制在计算机中，表示数据的范围：-8(23)-7(23-1)。

2、sizeof的作用有哪些？
有三种语法sizeof（object）、sizeof （object）、sizeof（type_name）
对象可以是各种类型的变量，以及表达式（一般sizeof不会对表达式进行计算）。
（1）	基本数据类型的sizeof
数据类型内存大小的简单计算。
（2）	结构体sizeof
结构体的sizeof涉及到字节对齐问题。
字节对齐有助于加快计算机的取值速度，否则旧的多花指令周期。
（3）	联合体sizeof
联合体是重叠的，各成员共享一段内存，所有整个联合体的sizeof就是每个成员sizeof的最大值
（4）	数组sizeof
数组的sizeof值等于数组所占用的内存字节数
（5）	指针的sizeof
指针是用来记录另一个对象的地址，指针的内存大小就等于计算及内部地址总线的宽度。
（6）	函数的sizeof
也可以对一个函数调用求值，其结果是函数返回值类型的大小，函数并不会被调用。

3、float a1 = 3.14f;中，f的作用是什么？
f代表浮点型。为浮点型类型的标识。

4、double和float取值的有效数字分别是多少？
Double为15-16位有效数字，float为7位有效数字，Cout默认输出六位有效数字。
更改有效数字的方法是cout.precision(n); n为有效数字个数。

5、如何提高有效数字的精度？
需要用到setprecision，控制小数点后数字精度需要用到setprecision和fixed，这两个操作符都包含在#include的头文件里面。
要求输出指定的n位有效数字

6、#define Day 7 和const修饰的变量组成的常量应用的场景有何区别？
（1）就起作用的阶段而言： #define是在编译的预处理阶段起作用，而const是在编译、运行的时候起作用。
（2）就起作用的方式而言： #define只是简单的字符串替换，没有类型检查。而const有对应的数据类型，是要进行判断的，可以避免一些低级的错误。 
（3）就存储方式而言：#define只是进行展开，有多少地方使用，就替换多少次，它定义的宏常量在内存中有若干个备份；const定义的只读变量在程序运行过程中只有一份备份。
（4）从代码调试的方便程度而言： const常量可以进行调试的，define是不能进行调试的，因为在预编译阶段就已经替换掉了。

7、using namespace std;中using的为何这么用？
namespace是指标识符的各种可见范围，C++标准库中所有标识符都被定义于一个名为std的namespace中。
C++标准为了和C区别开，为了正确的使用命名空间，规定头文件不使用后缀.h。当使用<iostream.h>时，相当于在C中调用库函数，使用的是全局命名空间，也就是早期的C++实现。当使用<iostream>时，该头文件没有定义全局命名空间，必须使用namespace std，这样才能使用类似于cout这样的C++标识符。
这样命名空间std内定义的所有标识符都有效。就好像被声明为全局变量一样。
